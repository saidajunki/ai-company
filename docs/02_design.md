# 設計（Design）

「余計な概念を増やさない」前提で、必要最低限の構成要素に分解する。

## 全体像

- Slack: 統治UI（相談・承認・報告）
- VPS: 実行基盤（シェル中心）
- 記憶: 一貫性の源泉（理念/意思決定/台帳）
- 台帳: 可観測性（コスト/作業/担当/成果）
- 公開: 成果確認（公開アーカイブ）

## 0) 実行環境（VPS丸ごと管理 + 会社の隔離）

前提: VPSは基本的にAIが丸ごと管理する。今後「会社」を複数作る可能性があるため、クリーンアップ容易性を優先して隔離単位を設ける。

隔離の候補（軽い順）:

- **ディレクトリ分離**: `companies/<company_id>/...` に状態と成果物を集約（最小構成）
- **コンテナ分離（採用: 1コンテナ=1会社）**: 会社ごとに「会社用コンテナ」を1つ作り、会社の作業はその中で完結させる（削除が容易）
- **VM相当**: パフォーマンスは落ちても良いので、より強い隔離が欲しい場合の選択肢

設計上は「会社＝隔離単位（ディレクトリ/コンテナ/VM）」として扱い、削除手順を単純にする（止める→消す、が成立する形）。

### 1コンテナ=1会社（＝“会社に1台PCを渡す”）

ここでのコンテナは「会社ごとの作業環境」を1つ立ち上げ、その中でAIが自由にシェルコマンドを実行できる状態を指す。

意図:
- データベース等が必要になっても **別コンテナは立てない**
- 必要なプロセス（中央管理AI、サブエージェント、必要ならDB等）を **同じ会社コンテナ内** で動かす

この形にすると「会社を消す」が「コンテナ停止→削除」と「会社ディレクトリ（volume）削除」に近づく。

重要:
- **社長AI（中央管理AI）を含む全エージェントは会社コンテナ内で生成/稼働する**
  - コンテナ外でエージェントに権限を持たせない（会社の権限境界を守る）
- コンテナ作成後、社長AIの初期起動は人為的に行う（ブートストラップ）
  - 以後は社長AIが自律的に社内エージェントを生成・運用してよい

### コンテナ vs VM（メリデメ）

**コンテナ（単一コンテナ）**
- 良い点: 起動が速い、軽い、依存の汚染が少ない、削除/作り直しが簡単、同一VPSで複数会社を並べやすい
- 弱い点: カーネル共有なので隔離はVMより弱い（脱出余地）、Dockerデーモンに触れると実質root権限、ホスト設定を直接いじる用途には向かない/注意が要る

**VM相当**
- 良い点: 隔離が強い（別カーネル）、破壊/侵害の影響範囲を物理的に狭めやすい、会社単位でOSや設定を変えやすい
- 弱い点: 重い（RAM/CPU/ディスク）、起動が遅い、運用が複雑、VPS環境によってはKVM等が使えないことがある

### 既存システムへ影響を出さないための“最小の運用境界”

制限でAIの行動範囲を狭めすぎない範囲で、事故を減らす境界だけ置く。

- 会社の作業は原則 `companies/<company_id>/...`（または会社用volume）に閉じる
- コンテナ/ネットワーク/ボリュームには会社IDのラベルを付け、同名衝突を避ける
- 既存スタック（別アプリ）のボリュームをマウントしない、同じポートを奪わない

## 1) Slack運用設計

### 10分レポート（新規投稿）

最低限の固定フォーマット（ノイズを減らし、比較しやすくする）:

- `WIP`: いま進行中（最大3件まで）
- `Δ(10m)`: 直近10分で進んだ差分（成果物リンク/ログリンク）
- `Next(10m)`: 次の10分でやること
- `Blockers`: 詰まり/権限不足/未解決
- `Cost(60m)`: 直近60分の概算消費と残り（$10上限）
- `Approvals`: 承認待ち（あれば）

許容:
- キリが悪ければレポートをスキップしてよい
- ±5分程度のズレは許容する

### 相談（詰まり）メッセージ

「質問 + 選択肢 + 見積 + リスク + 取り消し手順」を揃えて投げる。

### 承認依頼（有料/契約/公開リスク等）

承認依頼には必ず以下を含める:

- 何をしたいか / なぜ必要か
- 上限費用（または費用が不明である旨）
- 取り消し/停止手順
- 実行すると何が変わるか（データ・公開・課金・権限）

承認の返し方（決定）:
- 承認はSlackリアクションで行う
- 承認依頼メッセージに `request_id` を含め、「✅=承認 / ❌=却下」を明記する

## 2) 台帳（Ledger）設計: コスト・作業・成果の可視化

### コスト台帳（概算）

最初はトークン中心で十分。必須フィールド例:

- `timestamp`
- `agent_id`（誰が使ったか）
- `task_id`（何の作業か）
- `provider` / `model`
- `input_tokens` / `output_tokens`
- `unit_price_usd_per_1k_tokens`（参照した単価と、その取得日）
- `estimated_cost_usd`

有料API/外部サービスは「呼び出し回数 × 単価」の概算を追加で持てばよい。

### 永続先（暫定）

スキーマを決めても「どこに残すか」が曖昧だと運用が止まるため、まずは仮の置き場所を固定する。

- 会社ディレクトリ配下に置く: `companies/<company_id>/ledger/`
- フォーマットは **追記しやすい** ものから開始する（例: `events.ndjson`）
  - 1行=1イベント（LLM呼び出し、外部API呼び出し、シェル実行、意思決定、レポート送信など）
  - 後でSQLite等に移行しても良い（実装フェーズで判断）

### 60分移動窓（上限管理 + 評価）

- 直近60分の推定コストを常に集計
- 複雑な二段構えは入れない（実験前提）
- 10分レポートでは「どれくらい使ったか」と「今後どう配分する予定か」を共有する
- コスト上限を超えない限り、異常があっても停止より回復/継続を優先する

### OpenRouter単価（unit_price）の扱い

`unit_price_usd_per_1k_tokens` は「その時点で参照した単価スナップショット」を残すための値。

- 単価は変動し得るため、**値だけでなく取得日も必ず残す**
- 単価表（スナップショット）を会社ディレクトリ配下に置く:
  - `companies/<company_id>/pricing/openrouter.json`（または `pricing.ndjson`）
- 取得/更新タイミング（案）:
  - 起動時に1回（キャッシュを温める）
  - 未知の `model` が出たときに追加取得
  - 取得できない場合は「不明」として扱い、推定に使った根拠（仮単価/前回値）を台帳に残す

## 3) 記憶設計: “忘却/重複/迷走”を防ぐ最小セット

### 会社憲法（Constitution）

- 目的（研究開発中心）
- 公開方針（原則公開。実験として機微情報の公開も許容）
- 人間の介入範囲（契約/承認が主）
- 予算上限（$10/60分）
- 作業の基本原則（WIP制限、差分を残す、出典と日付を残す、など）

### 意思決定ログ（Decision Log）

「いつ・何を・なぜ・見直し条件」を残す。

### レジストリ（Registry）

最低限2つだけ:

- `agent_registry`: 社員（サブエージェント）一覧（役割、権限、使うモデル、予算上限）
- `service_registry`: 作ったサービス/リポジトリ/ドメイン等の一覧（重複防止）

## 3.1) 中央管理AIの起動と自律（常駐・イベント駆動）

`cron` で「起動する」思想は基本採らない。常に何らかのエージェントが動いている前提で、中央管理AIは常駐し、イベントで動く。

### 「常駐」の技術的な意味（実装イメージ）

ここでの常駐は「LLMが考え続ける」の意味ではなく、**長時間動き続けるプロセス**（例: `manager`）が存在し、
必要なタイミングでだけLLM/API/シェルを呼び出す、という意味。

最小構成のイメージ:
- 常駐プロセス（`manager`）: イベントを待ち受け、キューに積み、順に処理する
- 内部タイマー: 「だいたい10分」を監視して、進捗レポートを送る（厳密でなくてよい）
- 状態の永続化: WIP/台帳/意思決定ログを外部に残す（プロセスが再起動しても継続できる）

コンテキストウィンドウの限界への対処:
- 重要な状態は「会話ログ」ではなく **台帳・レジストリ・意思決定ログ** に置く
- LLMに渡すのは「いま必要な差分（WIP/直近の決定/直近の結果）」に絞る

OpenRouter等の呼び出しが途中で切れた場合:
- 1タスクを小さなステップに分け、ステップごとに結果を台帳に追記する（再開可能にする）
- 失敗時は「同じステップを再試行」できるように、入力/出力/実行コマンドを記録する

イベント例:
- Slack入力（相談/承認/依頼）
- 会社内ミーティング（定期 or 必要時）
- 予算確認（任意のタイミングで差し込む）
- 進捗レポートの時刻監視（だいたい10分に1回）

重要なのは「固いループ」よりも、以下が常に成立すること:
- いま何をしているか（WIP）が追える
- 止まっていないか（ハング/無限待ち）が検知できる
- レポートが途切れたら叩き起こせる

## 3.2) “レポートが来ない” をトリガーに叩き起こす（20分）

想定される停止パターン:
- ハングして進捗が詰まる
- タスクが尽きてループが回らない

対策:
- `last_report_at` を記録し、**20分以上レポートが出なければ** 中央管理AIを叩き起こす（再起動/再実行/割り込み）
- 叩き起こしは「新しい中央AIを作る」のではなく、同じ中央管理プロセスを回復させる（状態は台帳/レジストリから再ロード）
- これは自律性を損なわない範囲で、外側からの最小監視として置く
  - 実装手段としては `cron` を使ってもよい（監視用途のみ）

### 叩き起こしの実行主体（決定）

会社コンテナ内に監視を置くと「コンテナ自体がフリーズしたときに監視も死ぬ」ため、叩き起こしの実行主体は **ホスト側の最小watchdog**（AIではない）とする。

- watchdogは、会社ディレクトリ（または会社volume）にある **heartbeatファイル** を監視する
  - 例: `companies/<company_id>/state/heartbeat.json`
- 10分レポートはズレ/スキップがあり得るため、「Slack投稿がない」ではなく「heartbeatが更新されない」を異常判定の主にする
- 条件を満たしたらSlack通知→(A)/(B)の順で回復を試みる

叩き起こしの段階（決定）:
1. (A) まずは会社コンテナ内の `manager` プロセスを再起動する
2. (B) それでも復帰しなければ会社コンテナを再起動する
   - 状態は台帳/レジストリから再ロードして継続する

### 叩き起こし後に何をするか（“タスクが尽きた”対策）

叩き起こしても「やることがない」が続くとループになるため、叩き起こし直後の最初の一手を決めておく。

優先順（案）:
1. WIPがあるなら再開（詰まりを解消する）
2. 承認待ち/質問待ちなら、Creatorに「次の選択肢」と「いま待っているもの」を投げて待機する
3. タスクが本当にない場合は、Creatorに「次に何をするか」を相談する
4. それでも回答待ちなら、軽い社内ミーティング/自己レビュー（次の仮説と候補タスクを1件だけ作る）を行い、台帳に残す

## 3.3) 会社内ミーティング（作業以外の活動）

コードを書く以外に、方向性確認・予算確認・進め方のすり合わせを挟む。

初期は「相手がいない」状態になりやすいので、以下のどれでもよい:
- 中央管理AIの自己レビュー（短い振り返り）
- サブエージェント同士の作戦会議（必要になったら）
- Creatorへの相談（最優先）

ミーティングの出力は台帳/意思決定ログに残し、10分レポートには要約だけ載せる。
（生産性のないミーティングを避けるため、最低でも「結論（次のWIP/相談事項/実験案）」を1行で残す）

## 3.4) 会社憲法の変更プロセス（決定）

憲法（目的/公開/介入範囲/予算上限など）は、迷走防止のための最上位ドキュメント。

- 中央管理AIは憲法の変更を **提案** してよい（理由と影響つき）
- ただし憲法そのものの変更（適用）は **Creatorの承認が必要**
  - 承認前は「提案」として意思決定ログに残す
  - 承認されたら憲法を更新し、意思決定ログにも残す

## 4) 情報収集設計: “鮮度”を日付で扱う

カテゴリ固定や期限切りルールは置かない代わりに、すべての外部情報に:

- `retrieved_at`（取得日）
- `published_at`（公開日）
- `source`（どこから取ったか: Web検索/RSS/ニュース/ソーシャル等）
- `query`（どう探したか）

を付与し、AIは **日付込みで解釈** する。

情報源は以下のように“増やせる”構造にする（例）:
- Web検索
- RSS/ニュース（Googleニュース等）
- 開発者コミュニティ（GitHub, Hacker News等）
- ソーシャル（X, Instagram等）※必要なら契約・APIキー共有

## 5) 公開（成果物確認）の設計

実験前提で、公開物の品質ゲートや秘匿ルールは固定しない。

- 汚いデータが公開されること自体は許容する（運用がうまく回っていないシグナルとして扱う）
- その代わり、CreatorのFBを受けて作戦/構造を練り直せるよう「差分・日付・出典・再現手順（可能なら）」は残す

## 6) “シェルで完結”するための設計原則

- 作業はコマンド列として残す（再現性）
- 長い作業はログ/成果物に分離し、Slackには要約とリンクだけ投げる
- 可能ならコンテナ化して、VPS上での実行を標準化する

## 7) サブエージェントの生成・管理（コスト内で現実的に）

方針:
- 予算内であれば、必要に応じて何体でも生成してよい
- ただし現実的な判断として、以下が必要になった時に作る:
  - 並列化で明確に短縮できる
  - 目的関数が複数に分かれて衝突しうる（相互レビューが必要）
  - 中央のコンテキスト肥大化を防ぎたい
  - 専門性（例: 調査/実装/要約/運用）を分離したい

運用上の最低限:
- 生成したら `agent_registry` に登録する（役割、担当、使用モデル、概算コスト）
- 終了したら「成果物リンク + 要約 + 次の引き継ぎ」を残して廃止できるようにする
